{
  "version": 3,
  "sources": ["../src/util/fetch.js", "../src/util/boot.js", "../src/util/save.js", "../src/util/observer.js", "../src/index.js"],
  "sourcesContent": ["/**\r\n * To fetch the html of a page.\r\n * @param {Array} UrlArray - The array of URLs to fetch.\r\n * @returns {Promise} - The html of the page.\r\n */\r\nexport const getHtml = (UrlArray) => Promise.all(UrlArray.map((h) => fetch(\r\n    `https://api.allorigins.win/get?url=${encodeURIComponent(h)}`\r\n)\r\n  .then((r) => r.json())))\r\n", "// Boot the module on DOM content load\r\n\r\nexport const bootLibrary = () => {\r\n  const linksArray = document.querySelectorAll(\"a.hyperlinks\");\r\n  const hrefs = new Set();\r\n  return Promise.resolve(\r\n    Array.from(linksArray).filter(\r\n      ({ href }) => !hrefs.has(href) && hrefs.add(href)\r\n    )\r\n  );\r\n};\r\n", "// Store the collected data into Local Storage\r\n\r\n/**\r\n * Parse Raw HTML to a DOM tree.\r\n * @param {string} RawHtml -  Raw HTML.\r\n * @returns {object} - DOM tree.\r\n */\r\n\r\nexport const parseDOM = (RawHtml) => {\r\n  const PARSER = new DOMParser()\r\n  const DOC = PARSER.parseFromString(RawHtml, 'text/html')\r\n  return Promise.resolve(DOC)\r\n}\r\n/**\r\n * Store the meta data in LocalStorage.\r\n * @param {String} key - The url of the website.\r\n * @param {Object} meta - The meta data.\r\n */\r\n\r\nconst StoreMeta = (key, meta) => {\r\n  if (typeof window !== 'undefined') {\r\n    localStorage.setItem(key, JSON.stringify(meta))\r\n  }\r\n}\r\n\r\nexport const extractMetaTags = (parsedDOM, metaNames, anchorHref) => {\r\n  const METAS = {}\r\n  Array.from(parsedDOM.querySelectorAll('meta'))\r\n    .forEach((el) => {\r\n      const name = el.getAttribute('name') || el.getAttribute('property')\r\n      if (metaNames.includes(name)) {\r\n        METAS[name] = el.getAttribute('content') || 'Not available'\r\n      } else if (!name) {\r\n        // Handle case where name attribute is missing\r\n        const itemprop = el.getAttribute('itemprop')\r\n        if (metaNames.includes(itemprop)) {\r\n          METAS[itemprop] = el.getAttribute('content') || 'Not available'\r\n        }\r\n      }\r\n    })\r\n  // Assign 'Not available' to any missing meta tags\r\n  metaNames.forEach((name) => {\r\n    if (!METAS[name]) {\r\n      METAS[name] = 'Not available'\r\n    }\r\n  })\r\n  StoreMeta(anchorHref, METAS)\r\n  return METAS\r\n}\r\n\r\n/**\r\n * Check if the meta data is stored in LocalStorage.\r\n * @param {String} key - The url of the website.\r\n * @param {Array} HrefArray - The array of hrefs present in the DOM.\r\n * @returns {Array} - The array of hrefs which are not present in LocalStorage.\r\n */\r\n\r\nexport const HasMeta = (HrefArray) => Promise.resolve(HrefArray.filter(Checker))\r\n\r\nfunction Checker (key) {\r\n  return localStorage.getItem(key) === null\r\n}\r\n", "import { runner } from \"../index.js\";\r\n\r\n// Create a new MutationObserver\r\nexport const observer = new MutationObserver((mutations) => {\r\n  mutations.forEach((mutation) => {\r\n    if (mutation.type === \"childList\") {\r\n      const addedNodes = mutation.addedNodes;\r\n      for (let i = 0; i < addedNodes.length; i++) {\r\n        const node = addedNodes[i];\r\n        if (node.tagName === \"A\" && node.classList.contains(\"hyperlinks\")) {\r\n          console.log(\r\n            `%c[Hyperlinks] %cAnchor tag added: ${node.href}`,\r\n            \"color: cyan\",\r\n            \"color: white\"\r\n          );\r\n          runner();\r\n        }\r\n      }\r\n    } else if (\r\n      mutation.type === \"attributes\" &&\r\n      mutation.attributeName === \"href\"\r\n    ) {\r\n      const target = mutation.target;\r\n      if (target.tagName === \"A\" && target.classList.contains(\"hyperlinks\")) {\r\n        console.log(\r\n          `%c[Hyperlinks] %cAnchor tag href modified: ${target.href}`,\r\n          \"color: cyan\",\r\n          \"color: white\"\r\n        );\r\n        runner();\r\n      }\r\n    }\r\n  });\r\n});\r\n", "import { getHtml } from \"./util/fetch.js\";\r\nimport { bootLibrary } from \"./util/boot.js\";\r\nimport { parseDOM, extractMetaTags, HasMeta } from \"./util/save.js\";\r\nimport { observer } from \"./util/observer.js\";\r\n\r\nconst NEEDEDMETA = [\"og:image\", \"og:url\", \"og:title\", \"og:description\"];\r\n/* Future meta tags\r\nconst titleMetaTags = [\r\n  'og:title',\r\n  'twitter:title'\r\n];\r\n\r\nconst descriptionMetaTags = [\r\n  'og:description',\r\n  'twitter:description'\r\n];\r\n\r\n*/\r\nexport async function runner() {\r\n  const hrefArray = await bootLibrary();\r\n  const hrefFiltered = await HasMeta(hrefArray);\r\n  const rawHtmlArray = await getHtml(hrefFiltered);\r\n\r\n  for (const element of rawHtmlArray) {\r\n    const parsed = await parseDOM(element.contents);\r\n    extractMetaTags(parsed, NEEDEDMETA, element.status.url);\r\n  }\r\n}\r\n\r\nrunner();\r\nobserver.observe(document.documentElement, {\r\n  childList: true,\r\n  subtree: true,\r\n  attributes: true,\r\n  attributeFilter: [\"href\"],\r\n});\r\n\r\n// Planning on adding more settings to the Tooltip\r\nconst hyperlinksSettings = {};\r\n\r\nhyperlinksSettings.theme = document\r\n  .querySelector(\"head\")\r\n  .getAttribute(\"hyperlinksTheme\");\r\nconsole.log(`%c[Hyperlinks] %ctheme : ${hyperlinksSettings.theme}`, \"color: cyan\", \"color: white\");\r\n"],
  "mappings": "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",
  "names": []
}
